{"version":3,"file":"scrollyfills.cjs","sources":["../src/scrollend.js"],"sourcesContent":["// @ts-check\n\nconst supported = \"onscrollend\" in window\n\nif (!supported) {\n  const scrollendEvent = new Event('scrollend');\n  const pointers = new Set();\n\n  // Track if any pointer is active\n  document.addEventListener('touchstart', e => {\n    for (let touch of e.changedTouches) \n      pointers.add(touch.identifier)\n  }, {passive: true});\n\n  document.addEventListener('touchend', e => {\n    for (let touch of e.changedTouches)\n      pointers.delete(touch.identifier)\n  }, {passive: true});\n\n  // Map of scroll-observed elements.\n  let observed = new WeakMap();\n  let handle;\n  let snapshot;\n\n  // Forward and observe calls to a native method.\n  function observe(proto, method, handler) {\n    let native = proto[method];\n    proto[method] = function() {\n      let args = Array.prototype.slice.apply(arguments, [0]);\n      native.apply(this, args);\n      args.unshift(native);\n      handler.apply(this, args);\n    }\n  }\n  \n  function onAddListener(originalFn, type, handler, options) {\n    // Polyfill scrollend event on any element for which the developer listens\n    // to 'scrollend' explicitly or 'scroll' (so that adding a scrollend listener\n    // from within a scroll listener works).\n    if (type != 'scroll' && type != 'scrollend')\n      return;\n\n    let scrollport = this;\n    let data = observed.get(scrollport);\n    if (data === undefined) {\n      data = {\n        scrollListener: (evt) => {\n          if(typeof handle !== 'undefined') {\n            cancelAnimationFrame(handle);\n          }\n          handle = requestAnimationFrame(() => handle = requestAnimationFrame(() => {\n            if(typeof snapshot === 'undefined') {\n              snapshot = handle;\n            }\n            if(handle - snapshot > 30) {\n              if (pointers.size) {\n                // if pointer(s) are down, wait longer\n                setTimeout(data.scrollListener, 100)\n              }\n              else {\n                // dispatch\n                scrollport.dispatchEvent(scrollendEvent);\n              }\n              snapshot = handle;\n            }\n          }));\n        },\n        listeners: 0, // Count of number of listeners.\n      };\n      originalFn.apply(scrollport, ['scroll', data.scrollListener]);\n      observed.set(scrollport, data);\n    }\n    data.listeners++;\n  }\n\n  function onRemoveListener(originalFn, type, handler) {\n    if (type != 'scroll' && type != 'scrollend')\n      return;\n    let scrollport = this;\n    let data = observed.get(scrollport);\n\n    // Mismatched addEventListener / removeEventListener\n    // TODO: Should we explicitly track added listeners to prevent this?\n    if (data === undefined)\n      return;\n\n    data[type]--;\n    // If there are still listeners, nothing more to do.\n    if (--data.listeners > 0)\n      return;\n\n    // Otherwise, remove the added listeners.\n    originalFn.apply(scrollport, ['scroll', data.scrollListener]);\n    observed.delete(scrollport);\n  }\n\n  observe(Element.prototype, 'addEventListener', onAddListener);\n  observe(window, 'addEventListener', onAddListener);\n  observe(document, 'addEventListener', onAddListener);\n  observe(Element.prototype, 'removeEventListener', onRemoveListener);\n  observe(window, 'removeEventListener', onRemoveListener);\n  observe(document, 'removeEventListener', onRemoveListener);\n  // TODO: Polyfill onscroll, onscrollend as well?\n}\n"],"names":["window","observe","proto","method","handler","native","args","Array","prototype","slice","apply","arguments","this","unshift","onAddListener","originalFn","type","options","scrollport","data","observed","get","undefined","scrollListener","evt","handle","cancelAnimationFrame","requestAnimationFrame","snapshot","pointers","size","setTimeout","dispatchEvent","scrollendEvent","listeners","set","onRemoveListener","Set","document","addEventListener","e","_step","_iterator","_createForOfIteratorHelperLoose","changedTouches","done","add","identifier","passive","WeakMap","Element"],"mappings":"szBAIA,KAFkB,gBAAHA,QAEC,CAqBLC,IAAAA,EAAT,SAAiBC,EAAOC,EAAQC,GAC9B,IAAIC,EAASH,EAAMC,GACnBD,EAAMC,GAAU,WACd,IAAIG,EAAOC,MAAMC,UAAUC,MAAMC,MAAMC,UAAW,CAAC,IACnDN,EAAOK,MAAME,KAAMN,GACnBA,EAAKO,QAAQR,GACbD,EAAQM,MAAME,KAAMN,KA3BVQ,EA+Bd,SAAuBC,EAAYC,EAAMZ,EAASa,GAIhD,GAAY,UAARD,GAA4B,aAARA,EAAxB,CAGA,IAAIE,EAAaN,KACTO,EAAGC,EAASC,IAAIH,QACXI,IAATH,IACFA,EAAO,CACLI,eAAgB,SAACC,QACM,IAAlBC,GACDC,qBAAqBD,GAEvBA,EAASE,sBAAsB,WAAA,OAAYF,EAAGE,sBAAsB,gBAC3C,IAApBC,IACDA,EAAWH,GAEVA,EAASG,EAAW,KACjBC,EAASC,KAEXC,WAAWZ,EAAKI,eAAgB,KAIhCL,EAAWc,cAAcC,GAE3BL,EAAWH,QAIjBS,UAAW,GAEbnB,EAAWL,MAAMQ,EAAY,CAAC,SAAUC,EAAKI,iBAC7CH,EAASe,IAAIjB,EAAYC,IAE3BA,EAAKe,cAGEE,EAAT,SAA0BrB,EAAYC,EAAMZ,GAC1C,GAAY,UAARY,GAA4B,aAARA,EAAxB,CAEA,IAAcE,EAAGN,KACbO,EAAOC,EAASC,IAAIH,QAIXI,IAATH,IAGJA,EAAKH,OAECG,EAAKe,UAAY,IAIvBnB,EAAWL,MAAMQ,EAAY,CAAC,SAAUC,EAAKI,iBAC7CH,EAAA,OAAgBF,OAxFZe,EAAiB,UAAU,aAC3BJ,EAAW,IAAjBQ,IAGAC,SAASC,iBAAiB,aAAc,SAAAC,GACtC,IAAA,IAAAC,EAAAC,EAAAC,EAAkBH,EAAEI,kBAApBH,EAAAC,KAAAG,MACEhB,EAASiB,IAATjB,EAAAA,MAAmBkB,aACpB,CAACC,SAAS,IAEbV,SAASC,iBAAiB,WAAY,SAAAC,GACpC,IAAkBA,MAAAA,EAAAA,EAAAA,EAAEI,+BAClBf,EAAA,OAAAA,EAAAA,MAAsBkB,aACvB,CAACC,SAAS,IAGb,IACIvB,IADAL,EAAW,IAAf6B,QA4EAhD,EAAQiD,QAAQ1C,UAAW,mBAAoBM,GAC/Cb,EAAQD,OAAQ,mBAAoBc,GACpCb,EAAQqC,SAAU,mBAAoBxB,GACtCb,EAAQiD,QAAQ1C,UAAW,sBAAuB4B,GAClDnC,EAAQD,OAAQ,sBAAuBoC,GACvCnC,EAAQqC,SAAU,sBAAuBF"}